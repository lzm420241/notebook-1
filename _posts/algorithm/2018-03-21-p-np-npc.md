---
layout: post
title: P, NP,和 NPC
category: 算法
---

算法书上讲的算法，基本都是有效的解决问题的方法，这些算法的时间复杂度通常为多项式级别的，如 `O(n^2)`，`O(n^3)`，多项式复杂度与指数或阶乘复杂度，如 `O(2^N)`、`O(N!)`，比起来所需计算步数少很多，通常被认为是切实可行的算法，而指数或阶乘复杂度随着输入规模增大，求解问题所需的步数太多，这导致再怎么快的计算机用这种算法，在稍具规模的输入下就无法求出结果。

实际中遇到的种种问题中，有一些已经知道有切实可行的算法能在多项式时间内解决，而还有一些问题则只有指数时间复杂度的解决方案，还有一些人们甚至不知道问题到底有没有解。如果一个问题有解决方案，无论寻找解需多项式时间还是指数时间，但验证解是否正确只需要多项式时间，则称这种问题为搜索问题。

## NP, P

寻找问题的解，有时候如同大海捞针，但当拿出一个潜在的结果，要验证他是否为正确结果有时候则很容易。所有搜索问题，使用 NP 来描述。这些搜索问题中，可以在多项式时间内找出解的部分搜索问题，使用 P 来描述。即 NP 包含 P。而 P 不一定含 NP，除非所有搜索问题都有多项式时间的解法。


P 和 NP 还有这样一种定义：

> P: 确定性计算机能在多项式时间内解决的问题
>
> NP：非确定性计算机能在多项式时间内解决的问题

确定性计算机，就是目前见到的计算机，对于 `if - else if - else` 这样的多分支，确定性计算机只能一个条件一个条件的进行检验。而非确定性计算机可以并行地进行所有分支。非确定性计算机是人们设想出来的一种计算机。对于指数时间复杂度的问题，因为非确定性计算机可以并行处理一批搜索，而确定性计算机只能一个个尝试，所以非确定性计算机能够在多项式时间内解决。

## NPC

不同问题之间常常可以相互转化，即一个问题的解决方案，也许正是解决另外一个问题的基础。而一旦一个问题解决了，很多以此问题为基础的问题都迎刃而解了。一类问题之间的转化可能需要多项式时间，而一旦找到了其中最基本的这个问题的一个多项式解，那么所有其他问题也都有了多项式的解。所有存在一些最为根本的问题，所有其他尚未发现有多项式时间的解法的问题都以其为基础，如果这个根本问题是 NP 的，那么所有这些能够转化为该基本问题的问题就被称为 NPC（NP Complete，NP 完全）问题。

## 判断一个问题属于 P 还是属于 NPC

如果一个问题属于 P，那么应该能够找到一个多项式时间复杂度的解法。如果一个问题能够在多项式时间内转化为一个 NPC 问题，那么这个问题就是 NPC 的。

## 一些著名的 NPC 问题

- 布尔可满足性：给定 M 个由 N 个布尔变量组成的等式，找到一组使每个等式都成立的变量赋值，或者证明这样的赋值不存在。
- 整数线性规划：给定 M 个由 N 个整数变量组成的不等式，找出一组使所有不等式成立的变量赋值，或者证明这样的赋值不存在。
- 汉密尔顿路径：给定一幅图，找出一条正好只经过每个顶点一次的简单路径。

## 处理 NPC 问题

在实战中遇到 NPC 问题，应该能够快速辨别出来，并尝试使用近似解，而不是花费时间寻找最优解，因为最优解可能不存在，或者太难寻找了。
